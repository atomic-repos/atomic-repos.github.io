[{"authors":null,"categories":null,"content":"Hi there! Welcome to Atomic Repos. My name is Matt Stine, and I created Atomic Repos so that I could combine my love of Digital Writing with my love of Software Engineering.\n","date":1647302400,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1647302400,"objectID":"1a34779ef1109459d5eeed0a4e29167a","permalink":"https://atomicrepos.dev/author/matt-stine/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/matt-stine/","section":"authors","summary":"Hi there! Welcome to Atomic Repos. My name is Matt Stine, and I created Atomic Repos so that I could combine my love of Digital Writing with my love of Software Engineering.","tags":null,"title":"Matt Stine","type":"authors"},{"authors":null,"categories":null,"content":"Today we’re going to solve Project Euler Problem 2 in Kotlin. If you’re missing background on Project Euler and why I’m working through its problem set, take a look at Project Euler #1.\nHere’s our problem statement for today:  Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n  1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …\n  By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\n To solve this problem, we’re going to combine Kotlin’s Sequences with Kotlin’s Tuple Types Because we need two values to seed our sequence generation instead of one, we’ll need a way to pass two values as the seed argument to generateSequence. Now we could easily declare a data class that encapsulates the two values, but for situations like this it seems like overkill. Fortunately the designers of the Kotlin standard library agreed and added two such types for convenience: Pair and Triple. These types encapsulate two and three values (of any type!), respectively.\nNow we can pass the argument Pair(0,1) to generateSequence!\nOur function to generate the next value looks a little tricky, so let’s break it down. We’re returning Pair(it.second, it.first + it.second). Why does this work? Well, we know that the first two values in the Fibonacci sequence are 0 and 1. This means that the second Pair in our sequence is Pair(1,1). Continuing we find:\nPair(1,2) Pair(2,3) Pair(3,5) …  Comparing this sequence of pairs to the Fibonacci sequence described above, we can see that we are accumulating the entire sequence in the first value of each Pair!\nThe reset of the computation falls out nicely:\n We map each Pair to its first value. Next, we takeWhile the value is less than our upperBound. Then, we filter to only even numbers using it % 2 == 0. (For the uninitiated, % is the modulus operator!) And finally, we take the sum.  Running our program tells us the answer: 4613732.\nTo learn more about Kotlin Tuples, take a look at Pair and Triple in the Kotlin documentation.\n Code package dev.atomicrepos.kotlin.projecteuler fun evenFibonacciSum(upperBound: Int) = generateSequence(Pair(0, 1)) { Pair(it.second, it.first + it.second) } .map { it.first } .takeWhile { it \u0026lt; upperBound } .filter { it % 2 == 0 } .sum()  Tests package dev.atomicrepos.kotlin.projecteuler import org.assertj.core.api.Assertions.assertThat import org.junit.Test class ProjectEulerTwoTest { @Test fun shouldCalculateEvenFibonacciSum() { assertThat(evenFibonacciSum(4_000_000)).isEqualTo(4_613_732) } }  ","date":1647388800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1647388800,"objectID":"6509e3a0a59a110871313a1e11e998c0","permalink":"https://atomicrepos.dev/repos/project-euler-2-kotlin/","publishdate":"2022-03-16T00:00:00Z","relpermalink":"/repos/project-euler-2-kotlin/","section":"repos","summary":"Finds the sum of even-valued Fibonacci numbers ","tags":["project-euler","kotlin"],"title":"Project Euler #2 - Even Fibonacci Numbers - Kotlin","type":"repos"},{"authors":["Matt Stine"],"categories":null,"content":"Atomic Repos were inspired by the Atomic Essay concept developed by Dickie Bush and Nicholas Cole as part of Ship 30 for 30, what I consider the best available training and community dedicated to the game of Digital Writing.\nAtomic Essays are approximately 250-word essays that explain a single idea and are published as visual screenshot, normally to Twitter. After participating in three Ship 30 for 30 cohorts, I realized that a lot of things that I want to write don’t really lend themselves to the Atomic Essay format. But they could still benefit from the other principles and practices of online writing.\nEnter Atomic Repos! An Atomic Repo links an Atomic Essay illustrating an “atomic” coding concept in a single programming language with a GitHub repository containing code, tests, and continuous integration via GitHub Actions.\nGreat candidates for Atomic Repos include:\n Programming Exercises Project Euler Problems Code Katas Programming Cookbook-style Recipes … Really anything that you can describe in 250-300 words!  How Do They Work? The Atomic Repos site is a static site generated by Hugo. Hugo can ingest content from external sources using Hugo Modules, which under the hood leverage Go Modules.\nEach Atomic Repo is a Hugo Module that lives in its own GitHub repository. It contains a single page of Hugo content, which encapsulates the Atomic Essay portion (e.g. /content/repos/hello-world-java.md), and a code project nested within the static directory (e.g. /static/hello-world-java). The intention is that you should be able to import this project to your IDE/editor or use command-line tools as you would for any normal project of that type.\nHow Do I Contribute? It’s still early days for Atomic Repos, and I’m still working out a lot of kinks. When things stabilize (hopefully, after the March 2022 Ship 30 for 30 cohort), I’ll be creating documentation for the contributor workflow. Stay tuned to our Twitter for the latest updates!\n","date":1647302400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1647302400,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"https://atomicrepos.dev/about/","publishdate":"2022-03-15T00:00:00Z","relpermalink":"/about/","section":"","summary":"What are Atomic Repos?","tags":null,"title":"About Atomic Repos","type":"post"},{"authors":null,"categories":null,"content":"Today I’d like to introduce you to one of my favorite sources of programming problems: Project Euler.\nProject Euler is composed of a large set of problems (779 as of this writing) that will challenge both your mathematical and programming skills. The motivation is to provide a fun and recreational learning platform for students and professionals interested in math and/or computer science.\nWhat I like best about Project Euler’s problems is that they stretch each programming language in very different ways. For the polyglot programmer, Project Euler provides great fodder for exploring the capabilities of multiple languages. Often one programming language’s features or libraries provide it with a competitive advantage, allowing it to solve certain Project Euler problems more efficiently or elegantly. This is especially true of languages with a strong functional bent.\nHere’s our problem statement for today:  If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.\n Kotlin provides a powerful feature for attacking this problem: Lazy Sequences What’s cool about a lazy sequence? It can be infinitely long! This allows us to describe infinite sequences like the set of all natural numbers in a single line of code, and we never encounter a stack overflow! We can do this because lazy sequences are not evaluated until we ask for the result of a multi-step process.\nSo in today’s solution, we take each factor and:\n Multiply it by every number in our logically-infinite sequence of natural numbers. At this point we haven’t evaluated anything. Take all numbers from the sequence that are less than our upper bound of 1000. At this point, because we’ve established a concrete upper bound, Kotlin evaluates and returns a finite sequence of numbers. Because we now have a sequence of sequences, we combine them into one using flatten. We remove duplicates using distinct. And finally we take the sum.  Running our program tells us the answer: 233168.\nTo learn more about Kotlin Sequences, take a look at Sequences in the Kotlin documentation.\n Code package dev.atomicrepos.kotlin.projecteuler val naturalNumbers = generateSequence(1) { it + 1} fun sumOfMultiples(upperBound: Int, vararg factors: Int) = factors .asSequence() .map { factor -\u0026gt; naturalNumbers .map { it * factor } .takeWhile { it \u0026lt; upperBound } } .flatten() .distinct() .sum()  Tests package dev.atomicrepos.kotlin.projecteuler import org.assertj.core.api.Assertions.assertThat import org.junit.Test class ProjectEulerOneTest { @Test fun shouldCalculateSumOfMultiples() { assertThat(sumOfMultiples(1000, 3, 5)).isEqualTo(233168) } }  ","date":1647302400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1647302400,"objectID":"fbf866b0ae0666a2396553da9e226b60","permalink":"https://atomicrepos.dev/repos/project-euler-1-kotlin/","publishdate":"2022-03-15T00:00:00Z","relpermalink":"/repos/project-euler-1-kotlin/","section":"repos","summary":"Finds the sum of all multiples of 3 or 5 below 1000.","tags":["project-euler","kotlin"],"title":"Project Euler #1 - Multiples of 3 or 5 - Kotlin","type":"repos"},{"authors":null,"categories":null,"content":"Today we’re going to look at how Kotin allows you to easily filter and aggregate a data set using higher-order functions like map, filter, and reduce.\n(While Kotlin does have a reduce function, we’ll go ahead and use Kotlin’s average function since we’re taking an average in this example.)\nThis example was inspired by Exercise 40 from Exercises for Programmers: 57 Challenges to Develop Your Coding Skills. by Brian P. Hogan. In that exercise, you’re provided with a dataset of employees. We’re going to whip up our own dataset inspired by the characters in everyone’s favorite 90’s cult office-themed movie, Office Space.\nWe’ll be implementing the following “queries” on our “database”:\n Find all employees where their last name matches a search string. Find all employees with a specific job title. Find all employees that have been terminated since a specific date. Get the average service time (in days) for all employees. Get the average service time (in days) for all employees with a specific job title.  Higher-order functions are simply functions that can either accept other functions as arguments or return functions as values (or both!):\n map returns a new collection where each item is transformed by the function we provide. filter returns a new collection where each item is only retained if it matches the predicate function (a function that returns true or false) we provide. reduce returns a single value calculated by starting with the first item in the collection and applying the function we provide to each successive element, accumulating the “total” along the way. If we’d used reduce instead of average, we could have provided Long::plus and then divided the return value by employees.count().  If you’d like to explore more of Kotlin’s higher-order collection functions, take a look at Common Operations in the Kotlin documentation.\n Code package dev.atomicrepos.kotlin.mfr import java.time.* import java.time.temporal.ChronoUnit data class Employee( val firstName: String, val lastName: String, val jobTitle: JobTitle, val startDate: LocalDate, val separationDate: LocalDate? = null ) enum class JobTitle { MANAGER, SOFTWARE_ENGINEER, DISTRICT_MANAGER, DBA, WEB_DEVELOPER } fun findByLastNameLike(match: String) = employees.filter { it.lastName.contains(match) } fun findByPosition(match: JobTitle) = employees.filter { it.jobTitle == match } fun findTerminatedSince(match: LocalDate) = employees.filter { it.separationDate?.isAfter(match) ?: false } fun getAverageServiceTime() = employees .map(Employee::startDate) .map { it.until(dateOfTest, ChronoUnit.DAYS) } .average() fun getAverageServiceTimeByJobTitle(match: JobTitle) = employees.filter { it.jobTitle == match } .map(Employee::startDate) .map { it.until(dateOfTest, ChronoUnit.DAYS) } .average() /** * Fixed Date of March 15, 2022. Used for date-based math. */ val dateOfTest: LocalDate = LocalDate.ofInstant( Clock.fixed( Instant.parse(\u0026#34;2022-03-15T00:00:00.00Z\u0026#34;), ZoneId.of(\u0026#34;America/Chicago\u0026#34;) ).instant(), ZoneId.of(\u0026#34;America/Chicago\u0026#34;) ) val employees = listOf( Employee( firstName = \u0026#34;Matt\u0026#34;, lastName = \u0026#34;Stine\u0026#34;, jobTitle = JobTitle.SOFTWARE_ENGINEER, startDate = LocalDate.of( 2001, Month.JANUARY, 12 ) // 7731 days of service ), Employee( firstName = \u0026#34;Peter\u0026#34;, lastName = \u0026#34;Gibbons\u0026#34;, jobTitle = JobTitle.MANAGER, startDate = LocalDate.of( 1995, Month.SEPTEMBER, 15 ) // 9677 days of service ), Employee( firstName = \u0026#34;Michael\u0026#34;, lastName = \u0026#34;Bolton\u0026#34;, jobTitle = JobTitle.WEB_DEVELOPER, startDate = LocalDate.of( 1999, Month.FEBRUARY, 19 ), // 8424 days of service separationDate = LocalDate.of( 2022, Month.JANUARY, 15 ) ), Employee( firstName = \u0026#34;Samir\u0026#34;, lastName = \u0026#34;Nagheenanajar\u0026#34;, jobTitle = JobTitle.WEB_DEVELOPER, startDate = LocalDate.of( 1999, Month.FEBRUARY, 19 ), // 8424 days of service separationDate = LocalDate.of( 2022, Month.JANUARY, 15 ) ), Employee( firstName = \u0026#34;Bill\u0026#34;, lastName = \u0026#34;Lumbergh\u0026#34;, jobTitle = JobTitle.DISTRICT_MANAGER, startDate = LocalDate.of( 1975, Month.APRIL, 4 ) // 17146 days of service ) )  Tests package dev.atomicrepos.kotlin.mfr import org.assertj.core.api.Assertions.assertThat import org.junit.Test import java.time.LocalDate import java.time.Month class MapFilterReduceTest { @Test fun canFindByLastNameLike() { assertThat( findByLastNameLike(\u0026#34;Na\u0026#34;) .firstOrNull() ?.lastName ).isEqualTo(\u0026#34;Nagheenanajar\u0026#34;) } @Test fun missingLastNameMatchReturnsNull() { assertThat( findByLastNameLike(\u0026#34;Waddams\u0026#34;) .firstOrNull() ).isNull() } @Test fun canFindByPosition() { assertThat( findByPosition(JobTitle.WEB_DEVELOPER) .firstOrNull() ?.lastName ).isEqualTo(\u0026#34;Bolton\u0026#34;) } @Test fun canFindEmployeesTerminatedSince() { assertThat( findTerminatedSince(LocalDate.of(2022, Month.JANUARY, 1)) ).size().isEqualTo(2) } @Test fun canGetAverageServiceTime() { assertThat(getAverageServiceTime()).isEqualTo(10280.4) } @Test fun canGetAverageServiceTimeByJobTitle() { assertThat(getAverageServiceTimeByJobTitle(JobTitle.WEB_DEVELOPER)).isEqualTo(8424.0) } }  ","date":1647216e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1647216e3,"objectID":"f8d25c87f5eeaed6d0ed63c8d2c683e8","permalink":"https://atomicrepos.dev/repos/map-filter-reduce-kotlin/","publishdate":"2022-03-14T00:00:00Z","relpermalink":"/repos/map-filter-reduce-kotlin/","section":"repos","summary":"How to Map/Filter/Reduce a List of Objects in Kotlin","tags":["kotlin"],"title":"Map/Filter/Reduce Kotlin","type":"repos"},{"authors":null,"categories":null,"content":"What would normally be in your README.md would go here.\npackage main import \u0026#34;fmt\u0026#34; func SayHello() string { return \u0026#34;Hello, World!\u0026#34; } func main() { fmt.Println(SayHello()) }  ","date":1646611200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1646611200,"objectID":"6196040bafd194941ba27e5cf08a2ed8","permalink":"https://atomicrepos.dev/repos/hello-world-go/","publishdate":"2022-03-07T00:00:00Z","relpermalink":"/repos/hello-world-go/","section":"repos","summary":"Atomic Repos Template","tags":["template","go"],"title":"Hello, World!","type":"repos"},{"authors":null,"categories":null,"content":"What would normally be in your README.md would go here.\npackage dev.atomicrepos.java.hello_world; public class Hello { public static void main(String[] args) { System.out.println(new Hello().sayHello()); } public String sayHello() { return \u0026#34;Hello, World!\u0026#34;; } }  ","date":1646611200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1646611200,"objectID":"fc6d5ca4f18a565e74c4264620b377f9","permalink":"https://atomicrepos.dev/repos/hello-world-java/","publishdate":"2022-03-07T00:00:00Z","relpermalink":"/repos/hello-world-java/","section":"repos","summary":"Atomic Repos Template","tags":["template","java"],"title":"Hello, World!","type":"repos"},{"authors":null,"categories":null,"content":"What would normally be in your README.md would go here.\npackage dev.atomicrepos.kotlin.hello fun main(args: Array\u0026lt;String\u0026gt;) { println(\u0026#34;Hello, World\u0026#34;) }  ","date":1646611200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1646611200,"objectID":"460d423690e4bbb955351bd2f05284b5","permalink":"https://atomicrepos.dev/repos/hello-world-kotlin/","publishdate":"2022-03-07T00:00:00Z","relpermalink":"/repos/hello-world-kotlin/","section":"repos","summary":"Atomic Repos Template","tags":["template","kotlin"],"title":"Hello, World!","type":"repos"},{"authors":null,"categories":null,"content":"What would normally be in your README.md would go here.\nfn main() { println!(\u0026#34;Hello, world!\u0026#34;); }  ","date":1646611200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1646611200,"objectID":"cf9de794ffb2ae55660e2526b519ad07","permalink":"https://atomicrepos.dev/repos/hello-world-rust/","publishdate":"2022-03-07T00:00:00Z","relpermalink":"/repos/hello-world-rust/","section":"repos","summary":"Atomic Repos Template","tags":["template","rust"],"title":"Hello, World!","type":"repos"}]