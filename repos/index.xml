<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Repos | Atomic Repos</title><link>https://atomicrepos.dev/repos/</link><atom:link href="https://atomicrepos.dev/repos/index.xml" rel="self" type="application/rss+xml"/><description>Repos</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Wed, 16 Mar 2022 00:00:00 +0000</lastBuildDate><image><url>https://atomicrepos.dev/media/icon_hud0664d97edae6bbdbabef1d7c1dd89aa_83464_512x512_fill_lanczos_center_3.png</url><title>Repos</title><link>https://atomicrepos.dev/repos/</link></image><item><title>Project Euler #2 - Even Fibonacci Numbers - Kotlin</title><link>https://atomicrepos.dev/repos/project-euler-2-kotlin/</link><pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><guid>https://atomicrepos.dev/repos/project-euler-2-kotlin/</guid><description>&lt;p>Today we&amp;rsquo;re going to solve &lt;a href="https://projecteuler.net" target="_blank" rel="noopener">Project Euler&lt;/a> Problem 2 in Kotlin.
If you&amp;rsquo;re missing background on Project Euler and why I&amp;rsquo;m working through its problem set, take a look at &lt;a href="https://atomicrepos.dev/repos/project-euler-1-kotlin/">Project Euler #1&lt;/a>.&lt;/p>
&lt;h2 id="heres-our-problem-statement-for-today">Here&amp;rsquo;s our problem statement for today:&lt;/h2>
&lt;blockquote>
&lt;p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, &amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.&lt;/p>
&lt;/blockquote>
&lt;h2 id="to-solve-this-problem-were-going-to-combine-kotlins-sequences-with-kotlins-tuple-types">To solve this problem, we&amp;rsquo;re going to combine Kotlin&amp;rsquo;s Sequences with Kotlin&amp;rsquo;s Tuple Types&lt;/h2>
&lt;p>Because we need two values to seed our sequence generation instead of one, we&amp;rsquo;ll need a way to pass two values as the &lt;code>seed&lt;/code> argument to &lt;code>generateSequence&lt;/code>.
Now we could easily declare a data class that encapsulates the two values, but for situations like this it seems like overkill.
Fortunately the designers of the Kotlin standard library agreed and added two such types for convenience: &lt;code>Pair&lt;/code> and &lt;code>Triple&lt;/code>.
These types encapsulate two and three values (of any type!), respectively.&lt;/p>
&lt;p>Now we can pass the argument &lt;code>Pair(0,1)&lt;/code> to &lt;code>generateSequence&lt;/code>!&lt;/p>
&lt;p>Our function to generate the next value looks a little tricky, so let&amp;rsquo;s break it down. We&amp;rsquo;re returning &lt;code>Pair(it.second, it.first + it.second)&lt;/code>.
Why does this work?
Well, we know that the first two values in the Fibonacci sequence are 0 and 1.
This means that the second &lt;code>Pair&lt;/code> in our sequence is &lt;code>Pair(1,1)&lt;/code>. Continuing we find:&lt;/p>
&lt;ol start="3">
&lt;li>&lt;code>Pair(1,2)&lt;/code>&lt;/li>
&lt;li>&lt;code>Pair(2,3)&lt;/code>&lt;/li>
&lt;li>&lt;code>Pair(3,5)&lt;/code>&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ol>
&lt;p>Comparing this sequence of pairs to the Fibonacci sequence described above, we can see that we are accumulating the entire sequence in the first
value of each &lt;code>Pair&lt;/code>!&lt;/p>
&lt;p>The reset of the computation falls out nicely:&lt;/p>
&lt;ul>
&lt;li>We &lt;code>map&lt;/code> each &lt;code>Pair&lt;/code> to its first value.&lt;/li>
&lt;li>Next, we &lt;code>takeWhile&lt;/code> the value is less than our &lt;code>upperBound&lt;/code>.&lt;/li>
&lt;li>Then, we &lt;code>filter&lt;/code> to only even numbers using &lt;code>it % 2 == 0&lt;/code>. (For the uninitiated, &lt;code>%&lt;/code> is the &lt;a href="https://en.wikipedia.org/wiki/Modulo_operation" target="_blank" rel="noopener">modulus&lt;/a> operator!)&lt;/li>
&lt;li>And finally, we take the &lt;code>sum&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Running our program tells us the answer: &lt;code>4613732&lt;/code>.&lt;/p>
&lt;p>To learn more about Kotlin Tuples, take a look at &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/" target="_blank" rel="noopener">Pair&lt;/a> and &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-triple/" target="_blank" rel="noopener">Triple&lt;/a> in the Kotlin documentation.&lt;/p>
&lt;hr>
&lt;h2 id="code">Code&lt;/h2>
&lt;pre>&lt;code class="language-kotlin">package dev.atomicrepos.kotlin.projecteuler
fun evenFibonacciSum(upperBound: Int) =
generateSequence(Pair(0, 1)) {
Pair(it.second, it.first + it.second)
}
.map { it.first }
.takeWhile { it &amp;lt; upperBound }
.filter { it % 2 == 0 }
.sum()
&lt;/code>&lt;/pre>
&lt;h2 id="tests">Tests&lt;/h2>
&lt;pre>&lt;code class="language-kotlin">package dev.atomicrepos.kotlin.projecteuler
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test
class ProjectEulerTwoTest {
@Test
fun shouldCalculateEvenFibonacciSum() {
assertThat(evenFibonacciSum(4_000_000)).isEqualTo(4_613_732)
}
}
&lt;/code>&lt;/pre></description></item><item><title>Project Euler #1 - Multiples of 3 or 5 - Kotlin</title><link>https://atomicrepos.dev/repos/project-euler-1-kotlin/</link><pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate><guid>https://atomicrepos.dev/repos/project-euler-1-kotlin/</guid><description>&lt;p>Today I&amp;rsquo;d like to introduce you to one of my favorite sources
of programming problems: &lt;a href="https://projecteuler.net" target="_blank" rel="noopener">Project Euler&lt;/a>.&lt;/p>
&lt;p>Project Euler is composed of a large set
of problems (779 as of this writing) that will challenge both your mathematical and
programming skills. The motivation is to provide a fun and
recreational learning platform for students and professionals
interested in math and/or computer science.&lt;/p>
&lt;h2 id="what-i-like-best-about-project-eulers-problems-is-that-they-stretch-each-programming-language-in-very-different-ways">What I like best about Project Euler&amp;rsquo;s problems is that they stretch each programming language in very different ways.&lt;/h2>
&lt;p>For the polyglot programmer, Project Euler provides great
fodder for exploring the capabilities of multiple languages.
Often one programming language&amp;rsquo;s features or libraries
provide it with a competitive advantage, allowing it to solve
certain Project Euler problems more efficiently or elegantly.
This is especially true of languages with a strong functional
bent.&lt;/p>
&lt;h2 id="heres-our-problem-statement-for-today">Here&amp;rsquo;s our problem statement for today:&lt;/h2>
&lt;blockquote>
&lt;p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.&lt;/p>
&lt;/blockquote>
&lt;h2 id="kotlin-provides-a-powerful-feature-for-attacking-this-problem-lazy-sequences">Kotlin provides a powerful feature for attacking this problem: Lazy Sequences&lt;/h2>
&lt;p>What&amp;rsquo;s cool about a lazy sequence? It can be infinitely long!
This allows us to describe infinite sequences like
&lt;em>the set of all natural numbers&lt;/em> in a single line of code, and
we never encounter a stack overflow! We can do this because lazy
sequences are not evaluated until we ask for the result of
a multi-step process.&lt;/p>
&lt;p>So in today&amp;rsquo;s solution, we take each factor and:&lt;/p>
&lt;ol>
&lt;li>Multiply it by every number in our logically-infinite sequence of natural numbers. At this point we haven&amp;rsquo;t evaluated anything.&lt;/li>
&lt;li>Take all numbers from the sequence that are less than our upper bound of 1000. At this point, because we&amp;rsquo;ve established a concrete upper bound, Kotlin evaluates and returns a finite sequence of numbers.&lt;/li>
&lt;li>Because we now have a sequence of sequences, we combine them into one using &lt;code>flatten&lt;/code>.&lt;/li>
&lt;li>We remove duplicates using &lt;code>distinct&lt;/code>.&lt;/li>
&lt;li>And finally we take the &lt;code>sum&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>Running our program tells us the answer: &lt;code>233168&lt;/code>.&lt;/p>
&lt;p>To learn more about Kotlin Sequences, take a look at &lt;a href="https://kotlinlang.org/docs/sequences.html" target="_blank" rel="noopener">Sequences&lt;/a> in the Kotlin documentation.&lt;/p>
&lt;hr>
&lt;h2 id="code">Code&lt;/h2>
&lt;pre>&lt;code class="language-kotlin">package dev.atomicrepos.kotlin.projecteuler
val naturalNumbers = generateSequence(1) { it + 1}
fun sumOfMultiples(upperBound: Int, vararg factors: Int) =
factors
.asSequence()
.map { factor -&amp;gt;
naturalNumbers
.map { it * factor }
.takeWhile { it &amp;lt; upperBound }
}
.flatten()
.distinct()
.sum()
&lt;/code>&lt;/pre>
&lt;h2 id="tests">Tests&lt;/h2>
&lt;pre>&lt;code class="language-kotlin">package dev.atomicrepos.kotlin.projecteuler
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test
class ProjectEulerOneTest {
@Test
fun shouldCalculateSumOfMultiples() {
assertThat(sumOfMultiples(1000, 3, 5)).isEqualTo(233168)
}
}
&lt;/code>&lt;/pre></description></item><item><title>Map/Filter/Reduce Kotlin</title><link>https://atomicrepos.dev/repos/map-filter-reduce-kotlin/</link><pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate><guid>https://atomicrepos.dev/repos/map-filter-reduce-kotlin/</guid><description>&lt;p>Today we&amp;rsquo;re going to look at how Kotin allows you to easily filter and aggregate a data set using
higher-order functions like &lt;code>map&lt;/code>, &lt;code>filter&lt;/code>, and &lt;code>reduce&lt;/code>.&lt;/p>
&lt;p>(&lt;em>While Kotlin does have a &lt;code>reduce&lt;/code> function, we&amp;rsquo;ll go ahead and use Kotlin&amp;rsquo;s &lt;code>average&lt;/code> function since we&amp;rsquo;re taking an average in this example.&lt;/em>)&lt;/p>
&lt;p>This example was inspired by Exercise 40 from &lt;em>Exercises for Programmers: 57 Challenges to Develop Your Coding Skills.&lt;/em> by Brian P. Hogan.
In that exercise, you&amp;rsquo;re provided with a dataset of employees.
We&amp;rsquo;re going to whip up our own dataset inspired by the characters in everyone&amp;rsquo;s favorite 90&amp;rsquo;s cult
office-themed movie, &lt;em>Office Space&lt;/em>.&lt;/p>
&lt;p>We&amp;rsquo;ll be implementing the following &amp;ldquo;queries&amp;rdquo; on our &amp;ldquo;database&amp;rdquo;:&lt;/p>
&lt;ul>
&lt;li>Find all employees where their last name matches a search string.&lt;/li>
&lt;li>Find all employees with a specific job title.&lt;/li>
&lt;li>Find all employees that have been terminated since a specific date.&lt;/li>
&lt;li>Get the average service time (in days) for all employees.&lt;/li>
&lt;li>Get the average service time (in days) for all employees with a specific job title.&lt;/li>
&lt;/ul>
&lt;p>Higher-order functions are simply functions that can either accept other functions as arguments or return functions as values (or both!):&lt;/p>
&lt;ul>
&lt;li>&lt;code>map&lt;/code> returns a new collection where each item is transformed by the function we provide.&lt;/li>
&lt;li>&lt;code>filter&lt;/code> returns a new collection where each item is only retained if it matches the predicate function (a function that returns &lt;code>true&lt;/code> or &lt;code>false&lt;/code>) we provide.&lt;/li>
&lt;li>&lt;code>reduce&lt;/code> returns a single value calculated by starting with the first item in the collection and applying the function we provide to each successive element, accumulating the &amp;ldquo;total&amp;rdquo; along the way. If we&amp;rsquo;d used &lt;code>reduce&lt;/code> instead of &lt;code>average&lt;/code>, we could have provided &lt;code>Long::plus&lt;/code> and then divided the return value by &lt;code>employees.count()&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>If you&amp;rsquo;d like to explore more of Kotlin&amp;rsquo;s higher-order collection functions, take a look at &lt;a href="https://kotlinlang.org/docs/collection-operations.html#common-operations" target="_blank" rel="noopener">Common Operations&lt;/a> in the Kotlin documentation.&lt;/p>
&lt;hr>
&lt;h2 id="code">Code&lt;/h2>
&lt;pre>&lt;code class="language-kotlin">package dev.atomicrepos.kotlin.mfr
import java.time.*
import java.time.temporal.ChronoUnit
data class Employee(
val firstName: String,
val lastName: String,
val jobTitle: JobTitle,
val startDate: LocalDate,
val separationDate: LocalDate? = null
)
enum class JobTitle {
MANAGER, SOFTWARE_ENGINEER, DISTRICT_MANAGER, DBA, WEB_DEVELOPER
}
fun findByLastNameLike(match: String) =
employees.filter { it.lastName.contains(match) }
fun findByPosition(match: JobTitle) =
employees.filter { it.jobTitle == match }
fun findTerminatedSince(match: LocalDate) =
employees.filter { it.separationDate?.isAfter(match) ?: false }
fun getAverageServiceTime() =
employees
.map(Employee::startDate)
.map { it.until(dateOfTest, ChronoUnit.DAYS) }
.average()
fun getAverageServiceTimeByJobTitle(match: JobTitle) =
employees.filter { it.jobTitle == match }
.map(Employee::startDate)
.map { it.until(dateOfTest, ChronoUnit.DAYS) }
.average()
/**
* Fixed Date of March 15, 2022. Used for date-based math.
*/
val dateOfTest: LocalDate =
LocalDate.ofInstant(
Clock.fixed(
Instant.parse(&amp;quot;2022-03-15T00:00:00.00Z&amp;quot;),
ZoneId.of(&amp;quot;America/Chicago&amp;quot;)
).instant(),
ZoneId.of(&amp;quot;America/Chicago&amp;quot;)
)
val employees = listOf(
Employee(
firstName = &amp;quot;Matt&amp;quot;,
lastName = &amp;quot;Stine&amp;quot;,
jobTitle = JobTitle.SOFTWARE_ENGINEER,
startDate = LocalDate.of(
2001,
Month.JANUARY,
12
) // 7731 days of service
),
Employee(
firstName = &amp;quot;Peter&amp;quot;,
lastName = &amp;quot;Gibbons&amp;quot;,
jobTitle = JobTitle.MANAGER,
startDate = LocalDate.of(
1995,
Month.SEPTEMBER,
15
) // 9677 days of service
),
Employee(
firstName = &amp;quot;Michael&amp;quot;,
lastName = &amp;quot;Bolton&amp;quot;,
jobTitle = JobTitle.WEB_DEVELOPER,
startDate = LocalDate.of(
1999,
Month.FEBRUARY,
19
), // 8424 days of service
separationDate = LocalDate.of(
2022,
Month.JANUARY,
15
)
),
Employee(
firstName = &amp;quot;Samir&amp;quot;,
lastName = &amp;quot;Nagheenanajar&amp;quot;,
jobTitle = JobTitle.WEB_DEVELOPER,
startDate = LocalDate.of(
1999,
Month.FEBRUARY,
19
), // 8424 days of service
separationDate = LocalDate.of(
2022,
Month.JANUARY,
15
)
),
Employee(
firstName = &amp;quot;Bill&amp;quot;,
lastName = &amp;quot;Lumbergh&amp;quot;,
jobTitle = JobTitle.DISTRICT_MANAGER,
startDate = LocalDate.of(
1975,
Month.APRIL,
4
) // 17146 days of service
)
)
&lt;/code>&lt;/pre>
&lt;h2 id="tests">Tests&lt;/h2>
&lt;pre>&lt;code class="language-kotlin">package dev.atomicrepos.kotlin.mfr
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test
import java.time.LocalDate
import java.time.Month
class MapFilterReduceTest {
@Test
fun canFindByLastNameLike() {
assertThat(
findByLastNameLike(&amp;quot;Na&amp;quot;)
.firstOrNull()
?.lastName
).isEqualTo(&amp;quot;Nagheenanajar&amp;quot;)
}
@Test
fun missingLastNameMatchReturnsNull() {
assertThat(
findByLastNameLike(&amp;quot;Waddams&amp;quot;)
.firstOrNull()
).isNull()
}
@Test
fun canFindByPosition() {
assertThat(
findByPosition(JobTitle.WEB_DEVELOPER)
.firstOrNull()
?.lastName
).isEqualTo(&amp;quot;Bolton&amp;quot;)
}
@Test
fun canFindEmployeesTerminatedSince() {
assertThat(
findTerminatedSince(LocalDate.of(2022, Month.JANUARY, 1))
).size().isEqualTo(2)
}
@Test
fun canGetAverageServiceTime() {
assertThat(getAverageServiceTime()).isEqualTo(10280.4)
}
@Test
fun canGetAverageServiceTimeByJobTitle() {
assertThat(getAverageServiceTimeByJobTitle(JobTitle.WEB_DEVELOPER)).isEqualTo(8424.0)
}
}
&lt;/code>&lt;/pre></description></item><item><title>Hello, World!</title><link>https://atomicrepos.dev/repos/hello-world-go/</link><pubDate>Mon, 07 Mar 2022 00:00:00 +0000</pubDate><guid>https://atomicrepos.dev/repos/hello-world-go/</guid><description>&lt;p>What would normally be in your &lt;code>README.md&lt;/code> would go here.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func SayHello() string {
return &amp;quot;Hello, World!&amp;quot;
}
func main() {
fmt.Println(SayHello())
}
&lt;/code>&lt;/pre></description></item><item><title>Hello, World!</title><link>https://atomicrepos.dev/repos/hello-world-java/</link><pubDate>Mon, 07 Mar 2022 00:00:00 +0000</pubDate><guid>https://atomicrepos.dev/repos/hello-world-java/</guid><description>&lt;p>What would normally be in your &lt;code>README.md&lt;/code> would go here.&lt;/p>
&lt;pre>&lt;code class="language-java">package dev.atomicrepos.java.hello_world;
public class Hello {
public static void main(String[] args) {
System.out.println(new Hello().sayHello());
}
public String sayHello() {
return &amp;quot;Hello, World!&amp;quot;;
}
}
&lt;/code>&lt;/pre></description></item><item><title>Hello, World!</title><link>https://atomicrepos.dev/repos/hello-world-kotlin/</link><pubDate>Mon, 07 Mar 2022 00:00:00 +0000</pubDate><guid>https://atomicrepos.dev/repos/hello-world-kotlin/</guid><description>&lt;p>What would normally be in your &lt;code>README.md&lt;/code> would go here.&lt;/p>
&lt;pre>&lt;code class="language-kotlin">package dev.atomicrepos.kotlin.hello
fun main(args: Array&amp;lt;String&amp;gt;) {
println(&amp;quot;Hello, World&amp;quot;)
}
&lt;/code>&lt;/pre></description></item><item><title>Hello, World!</title><link>https://atomicrepos.dev/repos/hello-world-rust/</link><pubDate>Mon, 07 Mar 2022 00:00:00 +0000</pubDate><guid>https://atomicrepos.dev/repos/hello-world-rust/</guid><description>&lt;p>What would normally be in your &lt;code>README.md&lt;/code> would go here.&lt;/p>
&lt;pre>&lt;code class="language-rust">fn main() {
println!(&amp;quot;Hello, world!&amp;quot;);
}
&lt;/code>&lt;/pre></description></item></channel></rss>