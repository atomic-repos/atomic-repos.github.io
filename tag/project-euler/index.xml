<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>project-euler | Atomic Repos</title><link>https://atomicrepos.dev/tag/project-euler/</link><atom:link href="https://atomicrepos.dev/tag/project-euler/index.xml" rel="self" type="application/rss+xml"/><description>project-euler</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Wed, 16 Mar 2022 00:00:00 +0000</lastBuildDate><image><url>https://atomicrepos.dev/media/icon_hud0664d97edae6bbdbabef1d7c1dd89aa_83464_512x512_fill_lanczos_center_3.png</url><title>project-euler</title><link>https://atomicrepos.dev/tag/project-euler/</link></image><item><title>Project Euler #2 - Even Fibonacci Numbers - Kotlin</title><link>https://atomicrepos.dev/repos/project-euler-2-kotlin/</link><pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><guid>https://atomicrepos.dev/repos/project-euler-2-kotlin/</guid><description>&lt;p>Today we&amp;rsquo;re going to solve &lt;a href="https://projecteuler.net" target="_blank" rel="noopener">Project Euler&lt;/a> Problem 2 in Kotlin.
If you&amp;rsquo;re missing background on Project Euler and why I&amp;rsquo;m working through its problem set, take a look at &lt;a href="https://atomicrepos.dev/repos/project-euler-1-kotlin/">Project Euler #1&lt;/a>.&lt;/p>
&lt;h2 id="heres-our-problem-statement-for-today">Here&amp;rsquo;s our problem statement for today:&lt;/h2>
&lt;blockquote>
&lt;p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, &amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.&lt;/p>
&lt;/blockquote>
&lt;h2 id="to-solve-this-problem-were-going-to-combine-kotlins-sequences-with-kotlins-tuple-types">To solve this problem, we&amp;rsquo;re going to combine Kotlin&amp;rsquo;s Sequences with Kotlin&amp;rsquo;s Tuple Types&lt;/h2>
&lt;p>Because we need two values to seed our sequence generation instead of one, we&amp;rsquo;ll need a way to pass two values as the &lt;code>seed&lt;/code> argument to &lt;code>generateSequence&lt;/code>.
Now we could easily declare a data class that encapsulates the two values, but for situations like this it seems like overkill.
Fortunately the designers of the Kotlin standard library agreed and added two such types for convenience: &lt;code>Pair&lt;/code> and &lt;code>Triple&lt;/code>.
These types encapsulate two and three values (of any type!), respectively.&lt;/p>
&lt;p>Now we can pass the argument &lt;code>Pair(0,1)&lt;/code> to &lt;code>generateSequence&lt;/code>!&lt;/p>
&lt;p>Our function to generate the next value looks a little tricky, so let&amp;rsquo;s break it down. We&amp;rsquo;re returning &lt;code>Pair(it.second, it.first + it.second)&lt;/code>.
Why does this work?
Well, we know that the first two values in the Fibonacci sequence are 0 and 1.
This means that the second &lt;code>Pair&lt;/code> in our sequence is &lt;code>Pair(1,1)&lt;/code>. Continuing we find:&lt;/p>
&lt;ol start="3">
&lt;li>&lt;code>Pair(1,2)&lt;/code>&lt;/li>
&lt;li>&lt;code>Pair(2,3)&lt;/code>&lt;/li>
&lt;li>&lt;code>Pair(3,5)&lt;/code>&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ol>
&lt;p>Comparing this sequence of pairs to the Fibonacci sequence described above, we can see that we are accumulating the entire sequence in the first
value of each &lt;code>Pair&lt;/code>!&lt;/p>
&lt;p>The reset of the computation falls out nicely:&lt;/p>
&lt;ul>
&lt;li>We &lt;code>map&lt;/code> each &lt;code>Pair&lt;/code> to its first value.&lt;/li>
&lt;li>Next, we &lt;code>takeWhile&lt;/code> the value is less than our &lt;code>upperBound&lt;/code>.&lt;/li>
&lt;li>Then, we &lt;code>filter&lt;/code> to only even numbers using &lt;code>it % 2 == 0&lt;/code>. (For the uninitiated, &lt;code>%&lt;/code> is the &lt;a href="https://en.wikipedia.org/wiki/Modulo_operation" target="_blank" rel="noopener">modulus&lt;/a> operator!)&lt;/li>
&lt;li>And finally, we take the &lt;code>sum&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Running our program tells us the answer: &lt;code>4613732&lt;/code>.&lt;/p>
&lt;p>To learn more about Kotlin Tuples, take a look at &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/" target="_blank" rel="noopener">Pair&lt;/a> and &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-triple/" target="_blank" rel="noopener">Triple&lt;/a> in the Kotlin documentation.&lt;/p>
&lt;hr>
&lt;h2 id="code">Code&lt;/h2>
&lt;pre>&lt;code class="language-kotlin">package dev.atomicrepos.kotlin.projecteuler
fun evenFibonacciSum(upperBound: Int) =
generateSequence(Pair(0, 1)) {
Pair(it.second, it.first + it.second)
}
.map { it.first }
.takeWhile { it &amp;lt; upperBound }
.filter { it % 2 == 0 }
.sum()
&lt;/code>&lt;/pre>
&lt;h2 id="tests">Tests&lt;/h2>
&lt;pre>&lt;code class="language-kotlin">package dev.atomicrepos.kotlin.projecteuler
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test
class ProjectEulerTwoTest {
@Test
fun shouldCalculateEvenFibonacciSum() {
assertThat(evenFibonacciSum(4_000_000)).isEqualTo(4_613_732)
}
}
&lt;/code>&lt;/pre></description></item><item><title>Project Euler #1 - Multiples of 3 or 5 - Kotlin</title><link>https://atomicrepos.dev/repos/project-euler-1-kotlin/</link><pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate><guid>https://atomicrepos.dev/repos/project-euler-1-kotlin/</guid><description>&lt;p>Today I&amp;rsquo;d like to introduce you to one of my favorite sources
of programming problems: &lt;a href="https://projecteuler.net" target="_blank" rel="noopener">Project Euler&lt;/a>.&lt;/p>
&lt;p>Project Euler is composed of a large set
of problems (779 as of this writing) that will challenge both your mathematical and
programming skills. The motivation is to provide a fun and
recreational learning platform for students and professionals
interested in math and/or computer science.&lt;/p>
&lt;h2 id="what-i-like-best-about-project-eulers-problems-is-that-they-stretch-each-programming-language-in-very-different-ways">What I like best about Project Euler&amp;rsquo;s problems is that they stretch each programming language in very different ways.&lt;/h2>
&lt;p>For the polyglot programmer, Project Euler provides great
fodder for exploring the capabilities of multiple languages.
Often one programming language&amp;rsquo;s features or libraries
provide it with a competitive advantage, allowing it to solve
certain Project Euler problems more efficiently or elegantly.
This is especially true of languages with a strong functional
bent.&lt;/p>
&lt;h2 id="heres-our-problem-statement-for-today">Here&amp;rsquo;s our problem statement for today:&lt;/h2>
&lt;blockquote>
&lt;p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.&lt;/p>
&lt;/blockquote>
&lt;h2 id="kotlin-provides-a-powerful-feature-for-attacking-this-problem-lazy-sequences">Kotlin provides a powerful feature for attacking this problem: Lazy Sequences&lt;/h2>
&lt;p>What&amp;rsquo;s cool about a lazy sequence? It can be infinitely long!
This allows us to describe infinite sequences like
&lt;em>the set of all natural numbers&lt;/em> in a single line of code, and
we never encounter a stack overflow! We can do this because lazy
sequences are not evaluated until we ask for the result of
a multi-step process.&lt;/p>
&lt;p>So in today&amp;rsquo;s solution, we take each factor and:&lt;/p>
&lt;ol>
&lt;li>Multiply it by every number in our logically-infinite sequence of natural numbers. At this point we haven&amp;rsquo;t evaluated anything.&lt;/li>
&lt;li>Take all numbers from the sequence that are less than our upper bound of 1000. At this point, because we&amp;rsquo;ve established a concrete upper bound, Kotlin evaluates and returns a finite sequence of numbers.&lt;/li>
&lt;li>Because we now have a sequence of sequences, we combine them into one using &lt;code>flatten&lt;/code>.&lt;/li>
&lt;li>We remove duplicates using &lt;code>distinct&lt;/code>.&lt;/li>
&lt;li>And finally we take the &lt;code>sum&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>Running our program tells us the answer: &lt;code>233168&lt;/code>.&lt;/p>
&lt;p>To learn more about Kotlin Sequences, take a look at &lt;a href="https://kotlinlang.org/docs/sequences.html" target="_blank" rel="noopener">Sequences&lt;/a> in the Kotlin documentation.&lt;/p>
&lt;hr>
&lt;h2 id="code">Code&lt;/h2>
&lt;pre>&lt;code class="language-kotlin">package dev.atomicrepos.kotlin.projecteuler
val naturalNumbers = generateSequence(1) { it + 1}
fun sumOfMultiples(upperBound: Int, vararg factors: Int) =
factors
.asSequence()
.map { factor -&amp;gt;
naturalNumbers
.map { it * factor }
.takeWhile { it &amp;lt; upperBound }
}
.flatten()
.distinct()
.sum()
&lt;/code>&lt;/pre>
&lt;h2 id="tests">Tests&lt;/h2>
&lt;pre>&lt;code class="language-kotlin">package dev.atomicrepos.kotlin.projecteuler
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test
class ProjectEulerOneTest {
@Test
fun shouldCalculateSumOfMultiples() {
assertThat(sumOfMultiples(1000, 3, 5)).isEqualTo(233168)
}
}
&lt;/code>&lt;/pre></description></item></channel></rss>